package me.cutrats110;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Random;
import java.util.UUID;

import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.metadata.FixedMetadataValue;
import org.bukkit.plugin.Plugin;

public class MineswarmTeams {
	public Plugin plugin;
	//Team name as string, List of players, 0 being team owner.
	private HashMap<String, List<Player>> teams = new HashMap<>();
	//Player object, team they are a member of
	private HashMap<Player, String> players = new HashMap<>();
	//Players name, UUID of player
	private HashMap<String, UUID> UUIDLookup = new HashMap<>();
	//Player name, team name (assumes all requests are to join)
	private HashMap<String, String> joinRequests = new HashMap<>();
	//Player, team name (assumes all requests are to tp)
	//private HashMap<Player, String> tpRequests = new HashMap<>();//Broadcast request to all team members...//Waiting on thsi because of bukkit requirements to check if they have moved, damaged ect...
	
	@SuppressWarnings("unchecked")
	public MineswarmTeams(Plugin instance) {
		this.plugin = instance;
	      try {
	         FileInputStream fileIn = new FileInputStream(System.getProperty("user.dir") +"/plugins/Mineswarm/data.ser");
	         ObjectInputStream in = new ObjectInputStream(fileIn);
	         teams = (HashMap<String, List<Player>>) in.readObject();
	         in.close();
	         fileIn.close();
	      } catch (IOException | ClassNotFoundException i) {
	         plugin.getLogger().info(i.toString() + " WHILE DESER");
	         return;
	      }
		//Load serialized HashMaps?
	}

	public void addUUID(Player player) {//Gets called on join event...
		UUIDLookup.put(player.getName(), player.getUniqueId());
	}
	public boolean joinTeam(Player player, String team) {
		if(players.containsKey(player)) {
			player.sendMessage("You are already part of a team, leave that team before joining a new one");
		}
		else {
			Player teamOwner = teams.get(team).get(0);
			if(teamOwner != null) {//Not a server team
				teamOwner.sendMessage("Player " + player.getName() + " is requesting to join your team. /msteam add to add the player or /msteam deny to deny.");
				joinRequests.put(player.getName(), team);
				player.sendMessage("Join request sent, waiting for approval...");
				return true;
			}
		}
		return true;
	}
	public boolean joinTeamAccept(Player sender, String playerName) {
		String teamName = joinRequests.get(playerName);
		List<Player> members = teams.get(teamName);
		if(sender.equals(members.get(0)) || members.get(0).equals(null)) {//sender is the owner of the team being requested to join...
			Player requesty = Bukkit.getPlayer(UUIDLookup.get(playerName));
			if(requesty != null) {//Found a UUID match
				int maxSize = plugin.getConfig().getInt("max-team-size");
				if(members.size() <= maxSize) {
					members.add(requesty);
					teams.put(teamName, members);//Update hashmap with new player added
					joinRequests.remove(playerName);
					players.put(requesty, teamName);
					requesty.setMetadata("team_members",new FixedMetadataValue(plugin, teamName));
					requesty.sendMessage("Team request has been accepted!");
				}
				else {
					if(members.get(0).equals(null)) {
						//Find next public team to join...
					}
					else {
					sender.sendMessage("Team is full, you may only have "+String.valueOf(maxSize)+" players per team.");
					}
				}
			}
			
		}
		else {
			sender.sendMessage("You don't own this team so you can't accept join requests for that player");
		}
		
		return false;
		
	}
	public boolean joinTeamDeny(Player sender, String playerName) {
		String teamName = joinRequests.get(playerName);
		List<Player> members = teams.get(teamName);
		if(members.get(0).equals(sender)) {//Sender is owner
			Player requesty = Bukkit.getPlayer(UUIDLookup.get(playerName));
			joinRequests.remove(playerName);
			requesty.sendMessage("Team join request denied.");
		}
		return false;		
	}
	public boolean leaveTeam(Player player) {
		String team ="";
		
		try { team = player.getMetadata("team_members").get(0).asString();}
		catch(Exception err) {player.sendMessage("It doesn't seem like you are part of a team...");}
		List<Player> members = teams.get(team);
		if(members.contains(player)) {
			if(members.get(0).equals(player)) {//Owner is leaving team
				members.remove(player);
				teams.put(team, members);//Commit changes
				setNewTeamOwner(team);//Sets new owner...
				players.put(player, null);//Set player list to be in a null team
				player.sendMessage("You have left the team");
				player.setMetadata("team_members",new FixedMetadataValue(plugin, ""));
				return true;
			}
			else {//Standard member is leaving team...
				members.remove(player);
				teams.put(team, members);
				players.put(player, null);//Set player list to be in a null team
				player.sendMessage("You have left the team");
				player.setMetadata("team_members",new FixedMetadataValue(plugin, ""));

				return true;
			}
		}
		else {
			player.sendMessage("You are not a part of that team...");
		}
		
		return false;
	}
	
	
	/**
	 * Finds team owner from all active teams.
	 *
	 * @param Name of the team
	 * @return      Returns Player object (owner) if player is null the server owns the team
	 * @see         getTeamOwner
	 */
	public Player getTeamOwner(String team) {
		return teams.get(team).get(0);
	}
	public boolean isTeamMember(Player player, String teamName) {
		if(teams.get(teamName).contains(player)) {
			return true;
		}
		return false;
	}
	public List<Player> getTeamMembers(String teamName){
		return teams.get(teamName);
	}
	
	/**
	 * Creates a team instance with a specified owner; if player owner is null that means server is owner and team is random/public team
	 *
	 * @param Name of the team (how this team will be identified)
	 * @param Owner of team, server will be a null owner.
	 * @return      Returns true if team is successfully created.
	 * @see         createTeam
	 */
	public boolean createTeam(String name, Player player) {
		//Team name is available and team owner is NOT part of another team.
		List<Player> teamCheck = new ArrayList<>();
		teamCheck = teams.get(name);
		if (teamCheck != null) {
			//Key exists
		} else {
		    // Key might be present...
		    if (teams.containsKey(name)) {
		       // Okay, there's a key but the value is null
		    } else {
		       // Definitely no such key
		    	String playerTeam = players.get(player);
				if (playerTeam != null) {
					//Key exists
				} else {
				    // Key might be present...
				    if (players.containsKey(player)) {
				       // Okay, there's a key but the value is null
				    } else {
				       //Make team...
				    	players.put(player, name);
				    	List<Player> playerList = new ArrayList<>();
				    	playerList.add(player);
				    	teams.put(name, playerList);
				    	
				    	
				    	
				    }
				}
		    }
		}
		
		
		
		
		
		
		List<Player> ps = new ArrayList<>();
		ps.add(player);
		if(teams.get(name).isEmpty()) {
		//if(teams.putIfAbsent(name, ps) != null) {
			if(!(players.containsKey(player))) {
				teams.put(name, ps);
				if(player != null) {
					players.put(player, name);
				}
				return false;
			}
			else {
				if(player != null) {player.sendMessage("You are already part of a team, you must leave this team before");}
				return false;
			}
		}
		else//Team name already exists...
		{
			if(player != null) {player.sendMessage("That team name is already taken, please pick a different one");}
			return false;
		}
		
	}
	
	public boolean setNewTeamOwner(String teamName) {
		List<Player> members = teams.get(teamName);
		if(members.size() <= 1) {
			teams.remove(teamName);
			return true;
		}
		else {
			Random rand = new Random();
			int  n = rand.nextInt(members.size());
			Player newOwner = members.get(n);
			List<Player> newMembers = new ArrayList<>();
			newMembers.add(newOwner);
			for(Player player : members) {
				if(newOwner.equals(player)) {
					continue;
				}
				else {
					newMembers.add(player);
				}
			}
			teams.put(teamName, newMembers);

		}
		return false;
	}
	public boolean setNewTeamOwner(String teamName, String newOwnerName) {
		Player newOwner = Bukkit.getPlayer(UUIDLookup.get(newOwnerName));
		List<Player> members = teams.get(teamName);
		List<Player> newMembers = new ArrayList<>();
		newMembers.add(newOwner);
		for(Player player : members) {
			if(newOwner.equals(player)) {
				continue;
			}
			else {
				newMembers.add(player);
			}
		}
		teams.put(teamName, newMembers);
		return true;
	}
	public boolean kickTeamMember(String kicky, Player kicker) {
		if(getTeamOwner(players.get(kicker)).equals(kicker) && isTeamMember(Bukkit.getPlayer(UUIDLookup.get(kicky)), players.get(kicker))) {
			//Kicker is team owner and kicky is a member of the kicker's team.
			leaveTeam(Bukkit.getPlayer(UUIDLookup.get(kicky)));//Execute the leave function on behalf of kicked player.
			return true;			
		}
		return false;
	}
	
	//createTeam (name, overload-player) Method
	//joinTeam Method (name, player)
	//leaveTeam Method (name, player)
	//getTeamOwner(teamname) function
	//setTeamOwner(player) method
	//inTeam(teamname) function
	//getTeamMembers(teamname) function
	//kickTeamMember(player) method

	public boolean saveTeamData() {
		 try {
	         FileOutputStream fileOut = new FileOutputStream(System.getProperty("user.dir") +"/plugins/Mineswarm/data.ser");
	         ObjectOutputStream out = new ObjectOutputStream(fileOut);
	         out.writeObject(teams);
	         out.close();
	         fileOut.close();
	      } catch (IOException i) {
	         plugin.getLogger().info(i.toString());
	         return false;
	      }
		
		return true;
	}
		//tpaRequest(teamname) method
	
	//saveTeamData(teamname) method //Serialize the object, save in txt?
}
